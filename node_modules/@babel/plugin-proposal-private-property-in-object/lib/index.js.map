{"version":3,"names":["declare","api","opt","assertVersion","types","t","template","loose","classWeakSets","WeakMap","fieldsWeakSets","unshadow","name","targetScope","scope","hasOwnBinding","rename","parent","injectToFieldInit","fieldPath","expr","before","node","value","get","insertBefore","insertAfter","set","unaryExpression","injectInitialization","classPath","init","firstFieldPath","constructorPath","el","isClassProperty","isClassPrivateProperty","static","isClassMethod","kind","injectConstructorInit","expressionStatement","getWeakSetId","weakSets","outerClass","reference","inject","id","generateUidIdentifier","expression","ast","cloneNode","newExpr","newExpression","identifier","annotateAsPure","inherits","syntaxPlugin","default","pre","enableFeature","file","FEATURES","privateIn","visitor","BinaryExpression","path","state","operator","isPrivateName","left","privateElement","findParent","isClass","find","isPrivate","key","parentPath","isPattern","replaceWith","type","buildCheckInRHS","right"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxPlugin from \"@babel/plugin-syntax-private-property-in-object\";\nimport {\n  enableFeature,\n  FEATURES,\n  injectInitialization as injectConstructorInit,\n  buildCheckInRHS,\n} from \"@babel/helper-create-class-features-plugin\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, opt: Options) => {\n  api.assertVersion(7);\n  const { types: t, template } = api;\n  const { loose } = opt;\n\n  // NOTE: When using the class fields or private methods plugins,\n  // they will also take care of '#priv in obj' checks when visiting\n  // the ClassExpression or ClassDeclaration nodes.\n  // The visitor of this plugin is only effective when not compiling\n  // private fields and methods.\n\n  const classWeakSets: WeakMap<t.Class, t.Identifier> = new WeakMap();\n  const fieldsWeakSets: WeakMap<\n    t.ClassPrivateProperty | t.ClassPrivateMethod,\n    t.Identifier\n  > = new WeakMap();\n\n  function unshadow(name: string, targetScope: Scope, scope: Scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(\n    fieldPath: NodePath<t.ClassPrivateProperty | t.ClassProperty>,\n    expr: t.Expression,\n    before = false,\n  ) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(\n    classPath: NodePath<t.Class>,\n    init: t.Expression,\n  ) {\n    let firstFieldPath;\n    let constructorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if (\n        (el.isClassProperty() || el.isClassPrivateProperty()) &&\n        !el.node.static\n      ) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      injectConstructorInit(classPath, constructorPath, [\n        t.expressionStatement(init),\n      ]);\n    }\n  }\n\n  function getWeakSetId<Ref extends t.Node>(\n    weakSets: WeakMap<Ref, t.Identifier>,\n    outerClass: NodePath<t.Class>,\n    reference: NodePath<Ref>,\n    name = \"\",\n    inject: (\n      reference: NodePath<Ref>,\n      expression: t.Expression,\n      before?: boolean,\n    ) => void,\n  ) {\n    let id = weakSets.get(reference.node);\n\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      annotateAsPure(newExpr);\n\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n\n    return t.cloneNode(id);\n  }\n\n  return {\n    name: \"proposal-private-property-in-object\",\n    inherits: syntaxPlugin.default,\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const { node } = path;\n        const { file } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n\n        const { name } = node.left.id;\n\n        let privateElement: NodePath<\n          t.ClassPrivateMethod | t.ClassPrivateProperty\n        >;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n\n          privateElement = path.get(\"body.body\").find(\n            ({ node }) =>\n              // fixme: Support class accessor property\n              t.isPrivate(node) && node.key.id.name =